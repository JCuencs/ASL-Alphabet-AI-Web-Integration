<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sign Language Alphabet Recognition</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #6cbeed; min-height: 100vh; padding: 20px; }
.container { max-width: 1400px; margin: 0 auto; }
h1 { text-align: center; color: white; font-size: 2.5rem; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
.main-content { display: flex; gap: 20px; align-items: flex-start; }
.left-section { flex: 1; display: flex; flex-direction: column; gap: 20px; position: relative; }

.video-container {
  background: white;
  border-radius: 15px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  position: relative;
  overflow: hidden;
  padding: 0;
}

#webcam {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 15px;
}

.prediction-box { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); text-align: center; }
.prediction-label { font-size: 1.2rem; color: #333; margin-bottom: 15px; font-weight: 600; }
.prediction-text {
  font-size: 2.5rem; font-weight: bold; color: #6cbeed; min-height: 80px;
  display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
  border: 3px solid #e0e0e0; border-radius: 10px; background: #f9f9f9;
  padding: 10px; word-break: break-word; line-height: 1.2;
}
.button-group { display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap; }
.button-group button {
  padding: 12px 24px; font-size: 1rem; font-weight: 600; color: #fff;
  background-color: #6cbeed; border: none; border-radius: 10px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.2); cursor: pointer;
  transition: all 0.2s ease-in-out; min-width: 140px;
}
.button-group button:hover { background-color: #5aa0d4; transform: translateY(-2px); box-shadow: 0 7px 20px rgba(0,0,0,0.3); }
.button-group button:active { transform: translateY(0); }
.button-group button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; }
.chart-container { background: white; border-radius: 15px; padding: 20px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); flex: 0 0 400px; }
.chart-title { font-size: 1.3rem; color: #333; margin-bottom: 15px; text-align: center; font-weight: 600; }
.chart-image { width: 100%; height: auto; border-radius: 10px; }
.status { text-align: center; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 10px; color: white; margin-bottom: 20px; font-weight: 500; font-size: 0.9rem; }
.confidence-container {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px 16px;
  border-radius: 10px;
  font-weight: bold;
  font-size: 0.95rem;
  z-index: 5;
}
.prediction-status { font-size: 0.9rem; color: #666; margin-top: 10px; font-weight: 500; }
.prediction-status.active { color: #4CAF50; }
.prediction-status.inactive { color: #f44336; }

@media (max-width: 768px) {
  h1 { font-size: 1.8rem; margin-bottom: 20px; }
  .main-content { flex-direction: column; }
  .chart-container { flex: none; width: 100%; }
  .prediction-text { font-size: 2rem; min-height: 60px; }
  .button-group button { min-width: 110px; padding: 10px 16px; font-size: 0.9rem; }
}
</style>
</head>
<body>
<div class="container">
<h1>Sign Language Alphabet</h1>
<div class="status" id="status">Initializing...</div>

<div class="main-content">
    <div class="left-section">
        <div class="video-container">
            <video id="webcam" autoplay playsinline></video>
            <div class="confidence-container">
                <span id="confidence">Confidence: 0%</span>
            </div>
        </div>

        <div class="prediction-box">
            <div class="prediction-label">Predicted Letters</div>
            <div class="prediction-text" id="prediction">-</div>
            <div class="prediction-status" id="prediction-status">Status: Inactive</div>

            <div class="button-group">
                <button id="toggle-btn" disabled>Start</button>
                <button id="reset-btn">Clear</button>
                <button id="speak-btn">Speak</button>
            </div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Sign Language Guide</div>
        <img src="./ASL-Alphabet-poster-flashcards.png"
             alt="Sign Language Alphabet Chart" 
             class="chart-image"
             onerror="this.src='https://www.abcya.com/media/2020/11/sign-language-alphabet-reference-sheet.jpg'">
    </div>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>

<script>
// Option 1: Local model files (include tm_model folder in your deployment)
const MODEL_URL = "./tm_model/";

// Option 2: Use Teachable Machine cloud hosting (get this URL from TM export)
// const MODEL_URL = "https://teachablemachine.withgoogle.com/models/YOUR_MODEL_ID/";

let model;
let maxPredictions;
let webcam;
let isRunning = false;

const predictionElement = document.getElementById('prediction');
const statusElement = document.getElementById('status');
const confidenceElement = document.getElementById('confidence');
const predictionStatusElement = document.getElementById('prediction-status');
const toggleBtn = document.getElementById('toggle-btn');
const resetBtn = document.getElementById('reset-btn');
const speakBtn = document.getElementById('speak-btn');

let lastPredictedLetter = '';
let sameLetterCount = 0;
const SAME_LETTER_THRESHOLD = 3;
let predicting = false;

// Session state for tracking
let sessionState = {
    consecutivePredictions: 0,
    lastPredictionTime: 0,
    minConsecutiveFrames: 5
};

async function init() {
    statusElement.textContent = 'Loading model...';
    
    try {
        // Load the model and metadata
        const modelURL = MODEL_URL + "model.json";
        const metadataURL = MODEL_URL + "metadata.json";
        
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();
        
        statusElement.textContent = 'Model loaded! Initializing camera...';
        
        // Setup webcam
        const flip = true;
        webcam = new tmImage.Webcam(640, 480, flip);
        await webcam.setup();
        await webcam.play();
        
        // Append webcam canvas to video container
        const videoContainer = document.querySelector('.video-container');
        const existingWebcam = document.getElementById('webcam');
        existingWebcam.style.display = 'none';
        videoContainer.appendChild(webcam.canvas);
        webcam.canvas.style.width = '100%';
        webcam.canvas.style.height = 'auto';
        webcam.canvas.style.borderRadius = '15px';
        
        statusElement.textContent = 'Ready! Click Start to begin.';
        statusElement.style.background = 'rgba(76, 175, 80, 0.8)';
        toggleBtn.disabled = false;
        
        updatePredictionStatus();
        
    } catch (error) {
        console.error('Initialization error:', error);
        statusElement.textContent = 'Error: ' + error.message;
        statusElement.style.background = 'rgba(244, 67, 54, 0.8)';
    }
}

async function loop() {
    webcam.update();
    if (predicting) {
        await predict();
    }
    window.requestAnimationFrame(loop);
}

async function predict() {
    try {
        const prediction = await model.predict(webcam.canvas);
        
        // Find the class with highest probability
        let maxProb = 0;
        let predictedClass = '';
        
        for (let i = 0; i < prediction.length; i++) {
            if (prediction[i].probability > maxProb) {
                maxProb = prediction[i].probability;
                predictedClass = prediction[i].className;
            }
        }
        
        // Update confidence display
        const confidence = maxProb * 100;
        confidenceElement.textContent = `Confidence: ${confidence.toFixed(0)}%`;
        
        // Only add letter if confidence is high enough
        if (maxProb > 0.7) {
            sessionState.consecutivePredictions++;
            
            if (predictedClass === lastPredictedLetter) {
                sameLetterCount++;
            } else {
                lastPredictedLetter = predictedClass;
                sameLetterCount = 1;
            }
            
            // Check if we should add the letter
            const timeSinceLastPrediction = Date.now() - sessionState.lastPredictionTime;
            const shouldAddLetter = timeSinceLastPrediction > 800; // 800ms cooldown
            
            if (sameLetterCount >= SAME_LETTER_THRESHOLD && 
                shouldAddLetter && 
                sessionState.consecutivePredictions >= sessionState.minConsecutiveFrames) {
                
                if (predictionElement.textContent === '-') {
                    predictionElement.textContent = '';
                }
                
                const currentText = predictionElement.textContent;
                const lastChar = currentText.charAt(currentText.length - 1);
                
                // Only add if it's different from the last character
                if (lastChar !== predictedClass) {
                    predictionElement.textContent += predictedClass;
                    sessionState.lastPredictionTime = Date.now();
                }
                
                sameLetterCount = 0;
            }
        } else {
            sessionState.consecutivePredictions = 0;
            confidenceElement.textContent = 'Confidence: 0%';
        }
        
    } catch (error) {
        console.error('Prediction error:', error);
    }
}

toggleBtn.addEventListener('click', () => {
    predicting = !predicting;
    
    if (predicting) {
        toggleBtn.textContent = 'Stop';
        toggleBtn.style.backgroundColor = '#f44336';
        lastPredictedLetter = '';
        sameLetterCount = 0;
        sessionState.consecutivePredictions = 0;
        sessionState.lastPredictionTime = 0;
    } else {
        toggleBtn.textContent = 'Start';
        toggleBtn.style.backgroundColor = '#6cbeed';
        confidenceElement.textContent = 'Confidence: 0%';
    }
    
    updatePredictionStatus();
});

resetBtn.addEventListener('click', () => {
    predictionElement.textContent = '-';
    lastPredictedLetter = '';
    sameLetterCount = 0;
    confidenceElement.textContent = 'Confidence: 0%';
    sessionState.consecutivePredictions = 0;
    sessionState.lastPredictionTime = 0;
});

speakBtn.addEventListener('click', () => {
    const text = predictionElement.textContent;
    if (text && text !== '-') {
        speakText(text);
    }
});

function speakText(text) {
    window.speechSynthesis.cancel();
    
    const knownWords = checkForWords(text);
    
    if (knownWords.length > 0) {
        knownWords.forEach((word, index) => {
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.rate = 0.9;
                utterance.pitch = 1;
                utterance.volume = 1;
                window.speechSynthesis.speak(utterance);
            }, index * 1000);
        });
    } else {
        for (let i = 0; i < text.length; i++) {
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(text[i]);
                utterance.rate = 0.8;
                utterance.pitch = 1;
                utterance.volume = 1;
                window.speechSynthesis.speak(utterance);
            }, i * 600);
        }
    }
}

function checkForWords(text) {
    // Since we're only using A-E, no complete words will be formed
    // But we can still check for common patterns or sequences
    const textUpper = text.toUpperCase();
    
    // Check for simple patterns with A-E
    const patterns = {
        'BED': 'BED',
        'BAD': 'BAD',
        'DAD': 'DAD',
        'CAB': 'CAB',
        'ACE': 'ACE',
        'BEE': 'BEE',
        'DEE': 'DEE'
    };
    
    const foundWords = [];
    
    for (let [pattern, word] of Object.entries(patterns)) {
        if (textUpper.includes(pattern)) {
            foundWords.push(word);
        }
    }
    
    return foundWords;
}

function updatePredictionStatus() {
    if (predicting) {
        predictionStatusElement.textContent = 'Status: Active';
        predictionStatusElement.className = 'prediction-status active';
    } else {
        predictionStatusElement.textContent = 'Status: Inactive';
        predictionStatusElement.className = 'prediction-status inactive';
    }
}

// Initialize on page load
init().then(() => {
    loop();
});
</script>
</body>
</html>
