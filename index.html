<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sign Language Alphabet Recognition</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #6cbeed; min-height: 100vh; padding: 20px; }
.container { max-width: 1400px; margin: 0 auto; }
h1 { text-align: center; color: white; font-size: 2.5rem; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
.main-content { display: flex; gap: 20px; align-items: flex-start; }
.left-section { flex: 1; display: flex; flex-direction: column; gap: 20px; position: relative; }

.video-container {
  background: white;
  border-radius: 15px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  position: relative;
  overflow: hidden;
  padding: 0;
}

#webcam {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 15px;
}

#canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  border-radius: 15px;
}

.prediction-box { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); text-align: center; }
.prediction-label { font-size: 1.2rem; color: #333; margin-bottom: 15px; font-weight: 600; }
.prediction-text {
  font-size: 2.5rem; font-weight: bold; color: #6cbeed; min-height: 80px;
  display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
  border: 3px solid #e0e0e0; border-radius: 10px; background: #f9f9f9;
  padding: 10px; word-break: break-word; line-height: 1.2;
}
.button-group { display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap; }
.button-group button {
  padding: 12px 24px; font-size: 1rem; font-weight: 600; color: #fff;
  background-color: #6cbeed; border: none; border-radius: 10px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.2); cursor: pointer;
  transition: all 0.2s ease-in-out; min-width: 140px;
}
.button-group button:hover { background-color: #5aa0d4; transform: translateY(-2px); box-shadow: 0 7px 20px rgba(0,0,0,0.3); }
.button-group button:active { transform: translateY(0); }
.button-group button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; }
.chart-container { background: white; border-radius: 15px; padding: 20px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); flex: 0 0 400px; }
.chart-title { font-size: 1.3rem; color: #333; margin-bottom: 15px; text-align: center; font-weight: 600; }
.chart-image { width: 100%; height: auto; border-radius: 10px; }
.status { text-align: center; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 10px; color: white; margin-bottom: 20px; font-weight: 500; }
.confidence-container {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px 16px;
  border-radius: 10px;
  font-weight: bold;
  font-size: 0.95rem;
  z-index: 5;
}
.prediction-status { font-size: 0.9rem; color: #666; margin-top: 10px; font-weight: 500; }
.prediction-status.active { color: #4CAF50; }
.prediction-status.inactive { color: #f44336; }

@media (max-width: 768px) {
  h1 { font-size: 1.8rem; margin-bottom: 20px; }
  .main-content { flex-direction: column; }
  .chart-container { flex: none; width: 100%; }
  .prediction-text { font-size: 2rem; min-height: 60px; }
  .button-group button { min-width: 110px; padding: 10px 16px; font-size: 0.9rem; }
  #canvas { top: 0; left: 0; width: 100%; height: 100%; }
}
</style>
</head>
<body>
<div class="container">
<h1>Sign Language Alphabet</h1>

<div class="status" id="status">Initializing camera...</div>

<div class="main-content">
    <div class="left-section">
        <div class="video-container">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <div class="confidence-container">
                <span id="confidence">Confidence: 0%</span>
            </div>
        </div>

        <div class="prediction-box">
            <div class="prediction-label">Predicted Letters</div>
            <div class="prediction-text" id="prediction">-</div>
            <div class="prediction-status" id="prediction-status">Status: Inactive</div>

            <div class="button-group">
                <button id="toggle-btn">Start</button>
                <button id="reset-btn">Clear</button>
                <button id="speak-btn">Speak</button>
            </div>
        </div>

        <div class="chart-container" id="chart-mobile" style="display: none;">
            <div class="chart-title">Sign Language Guide</div>
            <img src="/ASL-Alphabet-poster-flashcards.png" 
                 alt="Sign Language Alphabet Chart" 
                 class="chart-image"
                 onerror="this.src='https://www.abcya.com/media/2020/11/sign-language-alphabet-reference-sheet.jpg'">
        </div>
    </div>

    <div class="chart-container" id="chart-desktop">
        <div class="chart-title">Sign Language Guide</div>
        <img src="/ASL-Alphabet-poster-flashcards.png" 
             alt="Sign Language Alphabet Chart" 
             class="chart-image"
             onerror="this.src='https://www.abcya.com/media/2020/11/sign-language-alphabet-reference-sheet.jpg'">
    </div>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
const API_URL = window.location.origin + '/api';
const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

let hands;
let pose;
let camera;
const videoElement = document.getElementById('webcam');
const canvasElement = document.getElementById('canvas');
const canvasCtx = canvasElement.getContext('2d');
const predictionElement = document.getElementById('prediction');
const statusElement = document.getElementById('status');
const confidenceElement = document.getElementById('confidence');
const predictionStatusElement = document.getElementById('prediction-status');

let sequence = [];
const SEQUENCE_LENGTH = 30;
let predicting = false;
let frameCount = 0;
const PREDICTION_INTERVAL = 10;
let lastPredictedLetter = '';
let sameLetterCount = 0;
const SAME_LETTER_THRESHOLD = 3;

// Store latest results from both models
let latestHandsResults = null;
let latestPoseResults = null;

const toggleBtn = document.getElementById('toggle-btn');
const resetBtn = document.getElementById('reset-btn');
const speakBtn = document.getElementById('speak-btn');

toggleBtn.addEventListener('click', () => { 
    predicting = !predicting;
    
    if (predicting) {
        toggleBtn.textContent = 'Stop';
        toggleBtn.style.backgroundColor = '#f44336';
        sequence = [];
    } else {
        toggleBtn.textContent = 'Start';
        toggleBtn.style.backgroundColor = '#6cbeed';
    }
    
    updatePredictionStatus();
});

resetBtn.addEventListener('click', () => { 
    predictionElement.textContent = '-'; 
    lastPredictedLetter = '';
    sameLetterCount = 0;
    confidenceElement.textContent = 'Confidence: 0%';
});

speakBtn.addEventListener('click', () => {
    const text = predictionElement.textContent;
    if (text && text !== '-') {
        speakText(text);
    }
});

function speakText(text) {
    window.speechSynthesis.cancel();
    
    const knownWords = checkForWords(text);
    
    if (knownWords.length > 0) {
        knownWords.forEach((word, index) => {
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.rate = 0.9;
                utterance.pitch = 1;
                utterance.volume = 1;
                window.speechSynthesis.speak(utterance);
            }, index * 1000);
        });
    } else {
        for (let i = 0; i < text.length; i++) {
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(text[i]);
                utterance.rate = 0.8;
                utterance.pitch = 1;
                utterance.volume = 1;
                window.speechSynthesis.speak(utterance);
            }, i * 600);
        }
    }
}

function checkForWords(text) {
    const commonWords = [
        'HELLO', 'HI', 'BYE', 'THANKS', 'PLEASE', 'YES', 'NO',
        'HELP', 'STOP', 'GO', 'COME', 'GOOD', 'BAD', 'OK',
        'LOVE', 'LIKE', 'WANT', 'NEED', 'HAVE', 'GET', 'GIVE'
    ];
    
    const textUpper = text.toUpperCase();
    const foundWords = [];
    
    if (commonWords.includes(textUpper)) {
        foundWords.push(textUpper);
        return foundWords;
    }
    
    for (let word of commonWords) {
        if (textUpper.includes(word)) {
            foundWords.push(word);
        }
    }
    
    return foundWords;
}

function updatePredictionStatus() {
    if (predicting) {
        predictionStatusElement.textContent = 'Status: Active';
        predictionStatusElement.className = 'prediction-status active';
    } else {
        predictionStatusElement.textContent = 'Status: Inactive';
        predictionStatusElement.className = 'prediction-status inactive';
    }
}

function handleResponsiveChart() {
    const chartMobile = document.getElementById('chart-mobile');
    const chartDesktop = document.getElementById('chart-desktop');
    if (window.innerWidth <= 768) {
        chartMobile.style.display = 'block';
        chartDesktop.style.display = 'none';
    } else {
        chartMobile.style.display = 'none';
        chartDesktop.style.display = 'block';
    }
}
window.addEventListener('resize', handleResponsiveChart);
handleResponsiveChart();

async function checkBackendHealth() {
    try {
        const response = await fetch(`${API_URL}/health`);
        const data = await response.json();
        
        if (data.status === 'healthy') {
            statusElement.textContent = 'Backend connected! Model ready.';
        } else {
            throw new Error('Backend not healthy');
        }
    } catch (error) {
        console.error('Backend health check failed:', error);
        statusElement.textContent = 'Cannot connect to backend. Please start the Flask server.';
    }
}

async function initializeMediaPipe() {
    // Initialize Hands
    hands = new Hands({ 
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` 
    });
    hands.setOptions({ 
        maxNumHands: 2, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5 
    });
    hands.onResults((results) => {
        latestHandsResults = results;
    });
    
    // Initialize Pose
    pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    pose.onResults((results) => {
        latestPoseResults = results;
    });
}

function extractKeypoints(handsResults, poseResults) {
    // Extract pose keypoints (33 landmarks × 4 features = 132)
    let poseArray = new Array(33 * 4).fill(0);
    if (poseResults && poseResults.poseLandmarks) {
        poseArray = [];
        for (let landmark of poseResults.poseLandmarks) {
            poseArray.push(landmark.x, landmark.y, landmark.z, landmark.visibility);
        }
    }
    
    // Extract hand keypoints (21 landmarks × 3 features = 63 each)
    let leftHand = new Array(21 * 3).fill(0);
    let rightHand = new Array(21 * 3).fill(0);
    
    if (handsResults && handsResults.multiHandLandmarks && handsResults.multiHandedness) {
        for (let i = 0; i < handsResults.multiHandLandmarks.length; i++) {
            const handLandmarks = handsResults.multiHandLandmarks[i];
            const handedness = handsResults.multiHandedness[i].label;
            
            const handArray = [];
            for (let lm of handLandmarks) {
                handArray.push(lm.x, lm.y, lm.z);
            }
            
            if (handedness === 'Left') {
                leftHand = handArray;
            } else {
                rightHand = handArray;
            }
        }
    }
    
    // Combine: pose (132) + left_hand (63) + right_hand (63) = 258 features
    return [...poseArray, ...leftHand, ...rightHand];
}

function isValidGesture(handsResults, poseResults) {
    return (handsResults && handsResults.multiHandLandmarks && handsResults.multiHandLandmarks.length > 0);
}

async function predict(keypoints, handsResults, poseResults) {
    if (!predicting || !isValidGesture(handsResults, poseResults)) {
        confidenceElement.textContent = 'Confidence: 0%';
        return;
    }
    
    sequence.push(keypoints);
    if (sequence.length > SEQUENCE_LENGTH) {
        sequence.shift();
    }
    
    frameCount++;
    
    if (sequence.length === SEQUENCE_LENGTH && frameCount % PREDICTION_INTERVAL === 0) {
        try {
            const response = await fetch(`${API_URL}/predict`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sequence: sequence
                })
            });
            
            if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
            
            const data = await response.json();
            
            const predictedLetter = data.prediction;
            const confidence = data.confidence * 100;
            
            confidenceElement.textContent = `Confidence: ${confidence.toFixed(0)}%`;
            
            if (confidence >= 70) {
                if (predictedLetter === lastPredictedLetter) {
                    sameLetterCount++;
                } else {
                    lastPredictedLetter = predictedLetter;
                    sameLetterCount = 1;
                }
                
                if (sameLetterCount >= SAME_LETTER_THRESHOLD) {
                    if (predictionElement.textContent === '-') {
                        predictionElement.textContent = '';
                    }
                    
                    const currentText = predictionElement.textContent;
                    const lastChar = currentText.charAt(currentText.length - 1);
                    
                    if (lastChar !== predictedLetter) {
                        predictionElement.textContent += predictedLetter;
                    }
                    
                    sameLetterCount = 0;
                }
            }
            
        } catch (error) {
            console.error('Prediction error:', error);
            statusElement.textContent = 'Prediction failed. Check if backend is running.';
        }
    }
}

async function onResults() {
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;
    
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    // Draw pose landmarks
    if (latestPoseResults && latestPoseResults.poseLandmarks) {
        drawConnectors(canvasCtx, latestPoseResults.poseLandmarks, POSE_CONNECTIONS, { 
            color: '#00FF00', lineWidth: 2 
        });
        drawLandmarks(canvasCtx, latestPoseResults.poseLandmarks, { 
            color: '#FF0000', lineWidth: 1, radius: 2 
        });
    }
    
    // Draw hand landmarks
    if (latestHandsResults && latestHandsResults.multiHandLandmarks) {
        for (const landmarks of latestHandsResults.multiHandLandmarks) {
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { 
                color: '#00FF00', lineWidth: 2 
            });
            drawLandmarks(canvasCtx, landmarks, { 
                color: '#FF0000', lineWidth: 1, radius: 3 
            });
        }
        
        const keypoints = extractKeypoints(latestHandsResults, latestPoseResults);
        predict(keypoints, latestHandsResults, latestPoseResults);
    } else {
        confidenceElement.textContent = 'Confidence: 0%';
    }
    
    canvasCtx.restore();
}

async function processFrame() {
    // Send frame to both models
    await hands.send({image: videoElement});
    await pose.send({image: videoElement});
    
    // Draw results
    onResults();
    
    // Continue processing
    requestAnimationFrame(processFrame);
}

async function initializeCamera() {
    try {
        camera = new Camera(videoElement, {
            onFrame: async () => {
                // This will be handled by processFrame
            },
            width: 1280,
            height: 720
        });
        
        await camera.start();
        statusElement.textContent = 'Camera ready! Checking backend...';
        
        await checkBackendHealth();
        
        // Start processing loop
        processFrame();
        
    } catch (error) {
        console.error('Camera error:', error);
        statusElement.textContent = 'Camera access denied. Please allow camera access.';
    }
}

async function initialize() {
    await initializeMediaPipe();
    await initializeCamera();
    updatePredictionStatus();
}

initialize();
</script>
</body>
</html>
