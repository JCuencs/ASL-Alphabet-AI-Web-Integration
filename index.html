<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sign Language Alphabet Recognition</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #6cbeed; min-height: 100vh; padding: 20px; }
.container { max-width: 1400px; margin: 0 auto; }
h1 { text-align: center; color: white; font-size: 2.5rem; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
.main-content { display: flex; gap: 20px; align-items: flex-start; }
.left-section { flex: 1; display: flex; flex-direction: column; gap: 20px; position: relative; }

.video-container {
  background: white;
  border-radius: 15px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  position: relative;
  overflow: hidden;
  padding: 0;
}

#webcam {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 15px;
}

#canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  border-radius: 15px;
}

.prediction-box { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); text-align: center; }
.prediction-label { font-size: 1.2rem; color: #333; margin-bottom: 15px; font-weight: 600; }
.prediction-text {
  font-size: 2.5rem; font-weight: bold; color: #6cbeed; min-height: 80px;
  display: flex; flex-wrap: wrap; align-items: center; justify-content: center;
  border: 3px solid #e0e0e0; border-radius: 10px; background: #f9f9f9;
  padding: 10px; word-break: break-word; line-height: 1.2;
}
.button-group { display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap; }
.button-group button {
  padding: 12px 24px; font-size: 1rem; font-weight: 600; color: #fff;
  background-color: #6cbeed; border: none; border-radius: 10px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.2); cursor: pointer;
  transition: all 0.2s ease-in-out; min-width: 140px;
}
.button-group button:hover { background-color: #5aa0d4; transform: translateY(-2px); box-shadow: 0 7px 20px rgba(0,0,0,0.3); }
.button-group button:active { transform: translateY(0); }
.button-group button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; }
.chart-container { background: white; border-radius: 15px; padding: 20px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); flex: 0 0 400px; }
.chart-title { font-size: 1.3rem; color: #333; margin-bottom: 15px; text-align: center; font-weight: 600; }
.chart-image { width: 100%; height: auto; border-radius: 10px; }
.status { text-align: center; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 10px; color: white; margin-bottom: 20px; font-weight: 500; }
.model-selector-container { background: white; border-radius: 10px; padding: 15px; margin-bottom: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
.model-selector-label { font-size: 0.9rem; color: #666; margin-bottom: 8px; font-weight: 600; }
.model-selector { width: 100%; padding: 10px; font-size: 1rem; border: 2px solid #6cbeed; border-radius: 8px; background: white; cursor: pointer; }
.confidence-container {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 8px 16px;
  border-radius: 10px;
  font-weight: bold;
  font-size: 0.95rem;
  z-index: 5;
}
.prediction-status { font-size: 0.9rem; color: #666; margin-top: 10px; font-weight: 500; }
.prediction-status.active { color: #4CAF50; }
.prediction-status.inactive { color: #f44336; }

@media (max-width: 768px) {
  h1 { font-size: 1.8rem; margin-bottom: 20px; }
  .main-content { flex-direction: column; }
  .chart-container { flex: none; width: 100%; }
  .prediction-text { font-size: 2rem; min-height: 60px; }
  .button-group button { min-width: 110px; padding: 10px 16px; font-size: 0.9rem; }
  #canvas { top: 0; left: 0; width: 100%; height: 100%; }
}
</style>
</head>
<body>
<div class="container">
<h1>Sign Language Alphabet</h1>

<div class="status" id="status">Initializing camera...</div>

<div class="main-content">
    <div class="left-section">
        <div class="model-selector-container">
            <div class="model-selector-label">Select Model:</div>
            <select id="model-selector" class="model-selector">
                <option value="lstm">Light</option>
                <option value="transformer">Standard</option>
            </select>
        </div>

        <div class="video-container">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <div class="confidence-container">
                <span id="confidence">Confidence: 0%</span>
            </div>
        </div>

        <div class="prediction-box">
            <div class="prediction-label">Predicted Letters</div>
            <div class="prediction-text" id="prediction">-</div>
            <div class="prediction-status" id="prediction-status">Status: Inactive</div>

            <div class="button-group">
                <button id="toggle-btn">Start</button>
                <button id="reset-btn">Clear</button>
                <button id="speak-btn">Speak</button>
            </div>
        </div>

        <div class="chart-container" id="chart-mobile" style="display: none;">
            <div class="chart-title">Sign Language Guide</div>
            <img src="/ASL-Alphabet-poster-flashcards.png" 
                 alt="Sign Language Alphabet Chart" 
                 class="chart-image"
                 onerror="this.src='https://www.abcya.com/media/2020/11/sign-language-alphabet-reference-sheet.jpg'">
        </div>
    </div>

    <div class="chart-container" id="chart-desktop">
        <div class="chart-title">Sign Language Guide</div>
        <img src="/ASL-Alphabet-poster-flashcards.png" 
             alt="Sign Language Alphabet Chart" 
             class="chart-image"
             onerror="this.src='https://www.abcya.com/media/2020/11/sign-language-alphabet-reference-sheet.jpg'">
    </div>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
const API_URL = 'http://localhost:5000/api';
const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

let hands;
let camera;
const videoElement = document.getElementById('webcam');
const canvasElement = document.getElementById('canvas');
const canvasCtx = canvasElement.getContext('2d');
const predictionElement = document.getElementById('prediction');
const statusElement = document.getElementById('status');
const confidenceElement = document.getElementById('confidence');
const predictionStatusElement = document.getElementById('prediction-status');

let sequence = [];
const SEQUENCE_LENGTH = 30;
let predicting = false;
let frameCount = 0;
const PREDICTION_INTERVAL = 10;
let lastPredictedLetter = '';
let sameLetterCount = 0;
const SAME_LETTER_THRESHOLD = 3;
let selectedModel = 'lstm';

const toggleBtn = document.getElementById('toggle-btn');
const resetBtn = document.getElementById('reset-btn');
const speakBtn = document.getElementById('speak-btn');

toggleBtn.addEventListener('click', () => { 
    predicting = !predicting;
    
    if (predicting) {
        toggleBtn.textContent = 'Stop';
        toggleBtn.style.backgroundColor = '#f44336'; // Red when active
        sequence = [];
    } else {
        toggleBtn.textContent = 'Start';
        toggleBtn.style.backgroundColor = '#6cbeed'; // Blue when inactive
    }
    
    updatePredictionStatus();
});

resetBtn.addEventListener('click', () => { 
    predictionElement.textContent = '-'; 
    lastPredictedLetter = '';
    sameLetterCount = 0;
    confidenceElement.textContent = 'Confidence: 0%';
});

speakBtn.addEventListener('click', () => {
    const text = predictionElement.textContent;
    if (text && text !== '-') {
        speakText(text);
    }
});

// Text-to-Speech function
function speakText(text) {
    // Cancel any ongoing speech
    window.speechSynthesis.cancel();
    
    // Check if text forms a known word
    const knownWords = checkForWords(text);
    
    if (knownWords.length > 0) {
        // Speak the words
        knownWords.forEach((word, index) => {
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.rate = 0.9;
                utterance.pitch = 1;
                utterance.volume = 1;
                window.speechSynthesis.speak(utterance);
            }, index * 1000);
        });
    } else {
        // Spell out letter by letter
        for (let i = 0; i < text.length; i++) {
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(text[i]);
                utterance.rate = 0.8;
                utterance.pitch = 1;
                utterance.volume = 1;
                window.speechSynthesis.speak(utterance);
            }, i * 600);
        }
    }
}

// Check if letters form known words
function checkForWords(text) {
    const commonWords = [
        'HELLO', 'HI', 'BYE', 'THANKS', 'PLEASE', 'YES', 'NO',
        'HELP', 'STOP', 'GO', 'COME', 'GOOD', 'BAD', 'OK',
        'LOVE', 'LIKE', 'WANT', 'NEED', 'HAVE', 'GET', 'GIVE',
        'MAKE', 'TAKE', 'SEE', 'LOOK', 'HEAR', 'LISTEN',
        'SPEAK', 'TALK', 'SAY', 'TELL', 'ASK', 'ANSWER',
        'KNOW', 'THINK', 'FEEL', 'BELIEVE', 'UNDERSTAND',
        'EAT', 'DRINK', 'SLEEP', 'WAKE', 'WORK', 'PLAY',
        'READ', 'WRITE', 'LEARN', 'TEACH', 'STUDY',
        'WALK', 'RUN', 'JUMP', 'SIT', 'STAND', 'LIE',
        'OPEN', 'CLOSE', 'START', 'END', 'BEGIN', 'FINISH',
        'BIG', 'SMALL', 'LARGE', 'LITTLE', 'TALL', 'SHORT',
        'LONG', 'WIDE', 'NARROW', 'THICK', 'THIN',
        'HOT', 'COLD', 'WARM', 'COOL', 'WET', 'DRY',
        'HAPPY', 'SAD', 'ANGRY', 'AFRAID', 'EXCITED',
        'NOW', 'LATER', 'SOON', 'NEVER', 'ALWAYS', 'SOMETIMES',
        'HERE', 'THERE', 'WHERE', 'WHEN', 'WHY', 'HOW', 'WHAT',
        'WHO', 'WHICH', 'THIS', 'THAT', 'THESE', 'THOSE',
        'ALL', 'SOME', 'MANY', 'FEW', 'MORE', 'LESS',
        'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE', 'TEN'
    ];
    
    const textUpper = text.toUpperCase();
    const foundWords = [];
    
    // Try to match the entire text first
    if (commonWords.includes(textUpper)) {
        foundWords.push(textUpper);
        return foundWords;
    }
    
    // Try to find words within the text
    for (let word of commonWords) {
        if (textUpper.includes(word)) {
            foundWords.push(word);
        }
    }
    
    return foundWords;
}

document.getElementById('model-selector').addEventListener('change', (e) => {
    selectedModel = e.target.value;
    statusElement.textContent = `Switched to ${selectedModel.toUpperCase()} model`;
});

function updatePredictionStatus() {
    if (predicting) {
        predictionStatusElement.textContent = 'Status: Active';
        predictionStatusElement.className = 'prediction-status active';
    } else {
        predictionStatusElement.textContent = 'Status: Inactive';
        predictionStatusElement.className = 'prediction-status inactive';
    }
}

function handleResponsiveChart() {
    const chartMobile = document.getElementById('chart-mobile');
    const chartDesktop = document.getElementById('chart-desktop');
    if (window.innerWidth <= 768) {
        chartMobile.style.display = 'block';
        chartDesktop.style.display = 'none';
    } else {
        chartMobile.style.display = 'none';
        chartDesktop.style.display = 'block';
    }
}
window.addEventListener('resize', handleResponsiveChart);
handleResponsiveChart();

async function checkBackendHealth() {
    try {
        const response = await fetch(`${API_URL}/health`);
        const data = await response.json();
        
        if (data.status === 'healthy') {
            statusElement.textContent = 'Backend connected! Models ready.';
        } else {
            throw new Error('Backend not healthy');
        }
    } catch (error) {
        console.error('Backend health check failed:', error);
        statusElement.textContent = 'Cannot connect to backend. Please start the Flask server.';
    }
}

async function initializeHands() {
    hands = new Hands({ 
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` 
    });
    hands.setOptions({ 
        maxNumHands: 2, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5 
    });
    hands.onResults(onResults);
}

function extractKeypoints(results) {
    let leftHand = Array(21*3).fill(0);
    let rightHand = Array(21*3).fill(0);
    
    if (results.multiHandLandmarks && results.multiHandedness) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
            const handLandmarks = results.multiHandLandmarks[i];
            const handedness = results.multiHandedness[i].label;
            
            const handArray = [];
            for (let lm of handLandmarks) {
                handArray.push(lm.x, lm.y, lm.z);
            }
            
            if (handedness === 'Left') {
                leftHand = handArray;
            } else {
                rightHand = handArray;
            }
        }
    }
    
    return [...leftHand, ...rightHand];
}

function isValidGesture(results) {
    return results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
}

async function predict(keypoints, results) {
    if (!predicting || !isValidGesture(results)) {
        confidenceElement.textContent = 'Confidence: 0%';
        return;
    }
    
    sequence.push(keypoints);
    if (sequence.length > SEQUENCE_LENGTH) {
        sequence.shift();
    }
    
    frameCount++;
    
    if (sequence.length === SEQUENCE_LENGTH && frameCount % PREDICTION_INTERVAL === 0) {
        try {
            const response = await fetch(`${API_URL}/predict`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sequence: sequence,
                    model: selectedModel
                })
            });
            
            if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
            
            const data = await response.json();
            
            const predictedLetter = data.prediction;
            const confidence = data.confidence * 100;
            
            confidenceElement.textContent = `Confidence: ${confidence.toFixed(0)}%`;
            
            if (confidence >= 70) {
                if (predictedLetter === lastPredictedLetter) {
                    sameLetterCount++;
                } else {
                    lastPredictedLetter = predictedLetter;
                    sameLetterCount = 1;
                }
                
                if (sameLetterCount >= SAME_LETTER_THRESHOLD) {
                    if (predictionElement.textContent === '-') {
                        predictionElement.textContent = '';
                    }
                    
                    const currentText = predictionElement.textContent;
                    const lastChar = currentText.charAt(currentText.length - 1);
                    
                    if (lastChar !== predictedLetter) {
                        predictionElement.textContent += predictedLetter;
                    }
                    
                    sameLetterCount = 0;
                }
            }
            
        } catch (error) {
            console.error('Prediction error:', error);
            statusElement.textContent = 'Prediction failed. Check if backend is running.';
        }
    }
}

function onResults(results) {
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;
    
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    if (results.multiHandLandmarks) {
        for (const landmarks of results.multiHandLandmarks) {
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { 
                color: '#00FF00', lineWidth: 2 
            });
            drawLandmarks(canvasCtx, landmarks, { 
                color: '#FF0000', lineWidth: 1, radius: 3 
            });
        }
        
        const keypoints = extractKeypoints(results);
        predict(keypoints, results);
    } else {
        confidenceElement.textContent = 'Confidence: 0%';
    }
    
    canvasCtx.restore();
}

async function initializeCamera() {
    try {
        camera = new Camera(videoElement, {
            onFrame: async () => { 
                await hands.send({image: videoElement}); 
            },
            width: 1280,
            height: 720
        });
        
        await camera.start();
        statusElement.textContent = 'Camera ready! Checking backend...';
        
        await checkBackendHealth();
        
    } catch (error) {
        console.error('Camera error:', error);
        statusElement.textContent = 'Camera access denied. Please allow camera access.';
    }
}

async function initialize() {
    await initializeHands();
    await initializeCamera();
    updatePredictionStatus();
}

initialize();
</script>
</body>
</html>
